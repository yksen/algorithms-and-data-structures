\documentclass{article}

\usepackage{amsmath}
\usepackage{enumitem}
\usepackage[polish]{babel}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[margin=1.5in]{geometry}
\usepackage[edges]{forest}
\usepackage{listings}

\begin{document}

\title{Algorytmy i struktury danych}
\author{}
\date{}
\maketitle

\section*{Lista zadań 2}

\subsection*{Zadanie 1}
Ile trzeba porównań, by znaleźć element $x$ w nieuporządkowanej tablicy \verb|t| o rozmiarze
$n$. Oblicz wartość średnią i wariancję zakładając, że element $x$ może znajdować się z
jednakowym prawdopodobieństwem, pod dowolnym indeksem tablicy.
\begin{gather*}
    E(X) = \sum_{i=1}^{n} x_ip_i = \sum_{i=1}^{n} i \cdot \frac{1}{n} = \frac{\left(\frac{1}{n}+\frac{n}{n}\right)n}{2} = \frac{n+1}{2} \\
    Var(X) = E(X^2) - E(X)^2 = \frac{n^2+1}{2} - \left(\frac{n+1}{2}\right)^2 = \frac{2n^2+2}{4} - \frac{n^2+2n+1}{4} = \frac{(n-1)^2}{4}
\end{gather*}

\subsection*{Zadanie 2}
Bisekcja. Ile trzeba porównań, by znaleźć element $x$ w posortowanej tablicy \verb|t| o rozmiarze
$n$. Podaj minimalną wartość gwarantującą sukces i strategię, jak to zrobić. Postaraj się
podać wzór ogólny, który pozwoli wyliczyć dokładną wartość dla dowolnego $n$. Sprawdź go dla $n = 1, \dots, 20$.
\begin{enumerate}
    \item Oblicz środek przedziału.
    \item Jeżeli wartość w środku przedziału jest równa $x$, to zakończ działanie algorytmu.
    \item Jeżeli wartość w środku przedziału jest większa od $x$, to środek staje się lewym końcem przedziału,
          w przeciwnym wypadku prawym.
\end{enumerate}
\begin{gather*}
    n=2 \implies 3 \\
    n=4 \implies 5 \\
    n=8 \implies 7 \\
    n=16 \implies 9 \\
    n=20 \implies 9 \\
    2 \lfloor \log_2(n) \rfloor + 1
\end{gather*}

\pagebreak
\subsection*{Zadanie 3}
Rozważ trzy wersje znajdowania maksimum w tablicy \verb|int maks(int t[], int n)|.
Ile porównań między elementami tablicy n-elementowej wykonuje każda z wersji? Ile
pamięci wymaga każda z tych wersji? Uwzględnij fakt, że głębokość rekurencji ma wpływ
na zużycie pamięci, ponieważ powstaje wiele kopii zmiennych lokalnych. Która wersja
jest więc najlepsza?
\begin{enumerate}[label=(\alph*)]
    \item iteracyjna: \verb|{int x = a[--n]; while(n--) if(t[n] > x) x = t[n]; return x;}|
          \begin{center}
              $n-1$ porównań i 3 zmienne lokalne
          \end{center}
    \item rekurencyjnie oblicza maksimum $n-1$ elementów i porównuje z ostatnim elementem
          \begin{center}
              $n-1$ porównań i $2n$ zmiennych lokalnych
          \end{center}
    \item dzieli tablicę na dwie części, rekurencyjnie znajduje ich maksima i wybiera większe z nich.
          \begin{center}
              $2(n-1)+1 = n-1$ porównań i $2(n-1) + 2 = 2n$ zmiennych lokalnych
          \end{center}
\end{enumerate}

\subsection*{Zadanie 4}
Jakie drzewo powstanie po wstawieniu do pustego drzewa BST liczb od 1 do $n$ w kolejności rosnącej?
Jaka potem będzie głębokość drzewa? Ile porównań kluczy wykonano w
trakcie tworzenia tego drzewa? Jaka jest złożoność w tego procesu w notacji $O$?
\smallskip \\
Uwaga: Element wstawiamy na pierwsze napotkane puste miejsce zaczynając od korze-
nia. Jeśli miejsce jest zajęte, to gdy element jest mniejszy od klucza w węźle, idziemy
do lewego poddrzewa, a gdy większy lub równy -- do prawego poddrzewa.

\begin{center}
    \begin{forest}
        for tree={circle, draw, minimum size=3ex, inner sep=1pt, s sep=7mm, anchor=south}
        [1]
    \end{forest}
    \begin{forest}
        for tree={circle, draw, minimum size=3ex, inner sep=1pt, s sep=7mm, anchor=south}
        [1 [, no edge, draw=none][2]]
    \end{forest}
    \begin{forest}
        for tree={circle, draw, minimum size=3ex, inner sep=1pt, s sep=7mm, anchor=south}
        [1 [, no edge, draw=none][2 [, no edge, draw=none][3]]]
    \end{forest}
    \begin{forest}
        for tree={circle, draw, minimum size=3ex, inner sep=1pt, s sep=7mm, anchor=south}
        [1 [, no edge, draw=none][2 [, no edge, draw=none][3 [, no edge, draw=none][4]]]]
    \end{forest}
\end{center}
\begin{align*}
    \text{Głębokość drzewa: } & n                                                         \\
    \text{Ilość porównań: }   & \sum_{i=1}^{n} i-1 = \frac{n(n-1)}{2} = \frac{n^2-n}{2} \\
    \text{Złożoność: }        & \frac{n^2-n}{2} = O(n^2)
\end{align*}

\end{document}